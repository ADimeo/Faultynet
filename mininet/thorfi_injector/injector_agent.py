"""
Note: Under  GPL-3.0 license license
Document source from ThorFI
"""
import asyncio
import re
import subprocess

from mininet import log

from subprocess import call

tc_path = '/usr/sbin'  # TODO make this refer to a binary we have in our download

"""Notes:

- Question: How _smart_ is the injector? Specifically, who holds the timer-until-start? Injector, or management agent?
    - Maybe go into phases, and within each phase there's autonomy, but the central controler pushes from phase to phase
    """


class Injector:

    def __init__(self,
                 target_interface=None,  # user-provided. Interfaces, like eth0. Expects a list
                 target_namespace_pid=None,
                 # user-provided, pid of the main node shell we should inject on
                 fault_target_traffic=None,
                 # user-provided, if fault target is not ANY_TRAFFIC generate cmds for injecting according to protocol
                 # and port number
                 fault_target_protocol=None,  # user-provided
                 fault_target_dst_ports=None,  # ???
                 fault_target_src_ports=None,  # ???
                 fault_type=None,  # user-provided, "delay", "persistent", "bottleneck", "down", "deletion", duplicate
                    # Netem allows [ LIMIT ] [ DELAY ] [ LOSS ] [ CORRUPT ] [ DUPLICATION] [ REORDERING ] [ RATE ] [ SLOT ]
                 fault_pattern=None,  # user-provided, "burst", "degradation"
                 fault_pattern_args=None,  # user-provided
                 fault_args=None,  # user-provided: how harsh failure is
                 pre_injection_time=0,  # user-provided, int, time before
                 injection_time=20,  # user-provided  int, time during
                 post_injection_time=0,  # user-provided,  int, time after
                 interface_owner=None):  # use-provided, generated by faultcontroller. Knows how I need to inject
        # into my interface

        # target_nics: is a list of network resources to be injected
        # fault: is the fault to be injected in the network resource
        # time: describe how last the injection

        self.target_interface = target_interface
        self.namespace_pid = target_namespace_pid

        self.fault_target_traffic = fault_target_traffic
        self.fault_target_protocol = fault_target_protocol
        self.fault_target_dst_ports = fault_target_dst_ports
        self.fault_target_src_ports = fault_target_src_ports

        self.fault_type = fault_type
        self.fault_pattern = fault_pattern
        self.fault_pattern_args = fault_pattern_args
        self.fault_args = fault_args

        self.pre_injection_time = pre_injection_time
        self.injection_time = injection_time
        self.post_injection_time = post_injection_time

        # self.target_name = target_name # used to id whether we're injecting into floating IP spaces
        # I don't think we'll ever do that, so I'm removing the relevant code
        self.interface_owner = interface_owner

        self.target_protocol_table = {
            'ICMP': '1',
            'IGMP': '2',
            'IP': '4',
            'TCP': '6',
            'UDP': '17',
            'IPv6': '41',
            'IPv6-ICMP': '58'
        }

    def setTargetInterface(self, target_interface):
        self.target_interface = target_interface

    def getTargetInterface(self):
        return self.target_interface

    def getFaultTargetTraffic(self):
        return self.fault_target_traffic

    def setFaultTargetTraffic(self, fault_target_traffic):
        self.fault_target_traffic = fault_target_traffic

    def getFaultTargetProtocol(self):
        return self.fault_target_protocol

    def setFaultTargetProtocol(self, fault_target_protocol):
        self.fault_target_protocol = fault_target_protocol

    def getFaultTargetDstPorts(self):
        return self.fault_target_dst_ports

    def setFaultTargetDstPorts(self, fault_target_dst_ports):
        self.fault_target_dst_ports = fault_target_dst_ports

    def getFaultTargetSrcPorts(self):
        return self.fault_target_src_ports

    def setFaultTargetSrcPorts(self, fault_target_src_ports):
        self.fault_target_src_ports = fault_target_src_ports

    def getFaultType(self):
        return self.fault_type

    def getFaultPattern(self):
        return self.fault_pattern

    def setFaultPattern(self, fault_pattern):
        self.fault_pattern = fault_pattern

    def getFaultPatternArgs(self):
        return self.fault_pattern_args

    def setFaultPatternArgs(self, fault_pattern_args):
        self.fault_pattern_args = fault_pattern_args

    def setFaultType(self, fault_type):
        self.fault_type = fault_type

    def getFaultArgs(self):
        return self.fault_args

    def setFaultArgs(self, fault_args):
        self.fault_args = fault_args

    def getPreInjectionTime(self):
        return float(self.pre_injection_time)

    def setPreInjectionTime(self, pre_injection_time):
        self.pre_injection_time = pre_injection_time

    def getInjectionTime(self):
        return float(self.injection_time)

    def setInjectionTime(self, injection_time):
        self.injection_time = injection_time

    def getPostInjectionTime(self):
        return float(self.post_injection_time)

    def setPostInjectionTime(self, post_injection_time):
        self.post_injection_time = post_injection_time

    def getTargetType(self):
        return self.target_type

    def setTargetType(self, target_type):
        self.target_type = target_type

    async def _inject_burst_pattern(self):
        # This uses nc s "persistent" pattern
        burst_config = self.getFaultPatternArgs()
        burst_duration = float(burst_config[0]) / 1000
        burst_period = float(burst_config[1]) / 1000

        log.info("injection time : %s\n" % self.getInjectionTime())
        burst_num = int((self.getInjectionTime()) / burst_period)

        log.info("Burst config: burst_duration: %s burst_period: %s burst_num: %s\n" % (
            burst_duration, burst_period, burst_num))

        for i in range(burst_num):
            # iterate over all target devices to enable injection
            interface = self.getTargetInterface()
            log.debug("BURST ENABLE injection on nic %s\n" % interface)
            self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'persistent', [''],
                             self.getFaultArgs(),
                             self.getFaultTargetTraffic(), self.getFaultTargetProtocol(),
                             self.getFaultTargetDstPorts(), self.getFaultTargetSrcPorts(), True)

            log.debug("WAIT BURST DURATION...%s\n" % burst_duration)
            await asyncio.sleep(burst_duration)

            log.debug("BURST DISABLE injection on nic %s \n" % interface)
            self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'persistent', [''],
                             self.getFaultArgs(),
                             self.getFaultTargetTraffic(), self.getFaultTargetProtocol(),
                             self.getFaultTargetDstPorts(), self.getFaultTargetSrcPorts(), False)

            log.debug("WAIT BURST remaining time...%s\n" % (burst_period - burst_duration))
            await asyncio.sleep(burst_period - burst_duration)

    async def _inject_degradation_pattern(self):
        # This uses nc s "random" pattern
        # increment for 'fault_pattern_args' each second
        degradation_step = 1
        degradation_config = self.getFaultPatternArgs()
        degradation_value = degradation_config[0]

        log.info("Degradation fault pattern!!!! Start with %s perc/s\n" % degradation_value)

        for i in range(int(self.getInjectionTime())):
            log.info("#%s step..." % i)
            # iterate over all target devices to enable injection
            interface = self.getTargetInterface()
            log.debug("DEGRADATION ENABLE injection on nic %s \n" % (interface))

            self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'random', [degradation_value],
                             self.getFaultArgs(), self.getFaultTargetTraffic(),
                             self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                             self.getFaultTargetSrcPorts(), True)

            log.debug("WAIT DEGRADATION DURATION...%s\n" % degradation_step)
            await asyncio.sleep(degradation_step)

            log.debug("DEGRADATION DISABLE injection on nic %s\n" % interface)
            self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'random', [degradation_value],
                             self.getFaultArgs(), self.getFaultTargetTraffic(),
                             self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                             self.getFaultTargetSrcPorts(), False)

            degradation_value = str(int(degradation_value) + int(degradation_config[0]))
            if int(degradation_value) > 100:
                degradation_value = str(100)

            log.debug("updated degradation value %s\n" % degradation_value)

    async def _inject_static_pattern(self):
        # iterate over all target devices to enable injection
        interface = self.getTargetInterface()
        log.debug("Enable injection on nic %s\n" % (interface))

        self.inject_nics(interface, self.namespace_pid, self.getFaultType(), self.getFaultPattern(),
                         self.getFaultPatternArgs(), self.getFaultArgs(), self.getFaultTargetTraffic(),
                         self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                         self.getFaultTargetSrcPorts(), True)

        log.info("Wait the injection time (%s s)\n" % self.getInjectionTime())
        await asyncio.sleep(self.getInjectionTime())

        # iterate over all target devices to disable injection
        log.debug("Disable injection on nic %s\n" % (interface))

        self.inject_nics(interface, self.namespace_pid, self.getFaultType(), self.getFaultPattern(),
                         self.getFaultPatternArgs(), self.getFaultArgs(), self.getFaultTargetTraffic(),
                         self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                         self.getFaultTargetSrcPorts(), False)

    async def go(self):
        await self.do_injection()

    async def do_injection(self):
        log.debug("Wait %s s of pre-injection time\n" % self.getPreInjectionTime())
        await asyncio.sleep(self.getPreInjectionTime())

        if 'burst' in self.getFaultPattern():
            await self._inject_burst_pattern()
        elif 'degradation' in self.getFaultPattern():
            await self._inject_degradation_pattern()
        else:
            await self._inject_static_pattern()

        ################ END INJECTION CODE ###################

        # wait 'self.post_injection_time' after removing injection injection
        log.debug("Wait %s s of post-injection time\n" % self.getPostInjectionTime())
        await asyncio.sleep(self.getPostInjectionTime())

    def make_nics_injection_command(self, node_pid, device, fault_type, fault_pattern, fault_pattern_args, fault_args,
                                    tc_cmd):
        log.debug(
            "[make_nics_injection_command] CONFIG: device %s, fault_type %s, fault_pattern %s, fault_pattern_args %s, fault_args %s, tc_cmd %s\n"
            % (device, fault_type, fault_pattern, fault_pattern_args, fault_args, tc_cmd))

        base_command = 'nsenter --target ' + str(
            node_pid) + ' --net  ' + tc_path + '/tc qdisc ' + tc_cmd + ' dev ' + device + ' root netem '
        command = None

        # NOTE: for NODE_DOWN and NIC_DOWN fault type does not make sense the random fault_pattern.
        #       we implement only a persistent flavor

        if 'random' in fault_pattern:
            if 'delay' in fault_type:
                # e.g., tc qdisc add dev tap0897f3c6-e0 root netem delay 50ms reorder 50%
                random_perc = 100 - int(fault_pattern_args)
                command = base_command + fault_type + ' ' + fault_args + ' reorder ' + str(random_perc) + '%'

            else:
                # in that case for corruption and loss we can use the 'fault_args' that already include random probability
                command = base_command + fault_type + ' ' + fault_pattern_args + '%'

        elif 'persistent' in fault_pattern:
            # Persistent fault type means setting a probability to 100%. For delay injection we can just use the default usage for 'delay' fault type

            if 'delay' in fault_type:
                command = base_command + fault_type + ' ' + fault_args

            elif 'bottleneck' in fault_type:
                # the command is like: tc qdisc add dev tapa68bfef8-df root tbf rate 256kbit burst 1600 limit 3000
                default_bottleneck_burst = '1600'
                default_limit_burst = '3000'
                command = 'nsenter --target ' + str(
                    node_pid) + ' --net  ' + tc_path + '/tc qdisc ' + tc_cmd + ' dev ' + device + ' root tbf rate ' + fault_args + 'kbit burst ' + default_bottleneck_burst + ' limit ' + default_limit_burst

            elif 'down' in fault_type:
                # TODO implement/test this
                if 'add' in tc_cmd:
                    # search for ifdown cmd
                    p = subprocess.Popen('whereis -b ifdown | awk \'{print $2}\'', stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
                    output, err = p.communicate()
                    ifdown_cmd = output.strip()
                    if ifdown_cmd:
                        command = ifdown_cmd + ' ' + device
                elif 'del' in tc_cmd:
                    # search for ifdown cmd
                    p = subprocess.Popen('whereis -b ifup | awk \'{print $2}\'', stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
                    output, err = p.communicate()
                    ifup_cmd = output.strip()
                    if ifup_cmd:
                        command = ifup_cmd + ' ' + device
            else:
                # in that case for corruption and loss we can use the 'fault_args' to set 100% probability
                command = base_command + fault_type + ' 100%'
        return command

    def make_filter_cmds(self, node_pid, fault_pattern, fault_pattern_args, fault_type, fault_args, device,
                         target_protocol,
                         target_dst_ports=None, target_src_ports=None, enable=False):

        log.debug(
            "[make_filter_cmds] CONFIG: fault_pattern %s, fault_pattern_args %s, fault_type %s, fault_args %s, device %s, target_protocol %s, target_dst_ports %s, target_src_ports %s, enable %s\n"
            % (fault_pattern, fault_pattern_args, fault_type, fault_args, device, target_protocol, target_dst_ports,
               target_src_ports, enable))

        if enable:
            base_command = 'nsenter --target ' + str(
                node_pid) + ' --net  ' + tc_path + '/tc filter add dev ' + device + ' parent 1:0 protocol ip prio 1 u32 '
            cmd_list = [tc_path + '/tc qdisc add dev ' + device + ' root handle 1: prio']

            target_protocol_cmd = 'match ip protocol ' + self.target_protocol_table[target_protocol] + ' 0xff'

            if target_dst_ports:
                for target_port in target_dst_ports:
                    target_port_cmd = 'match ip dport ' + str(target_port) + ' 0xffff'
                    cmd_list.append(base_command + target_protocol_cmd + ' ' + target_port_cmd + ' flowid 1:1')
            if target_src_ports:
                for target_port in target_src_ports:
                    target_port_cmd = 'match ip sport ' + str(target_port) + ' 0xffff'
                    cmd_list.append(base_command + target_protocol_cmd + ' ' + target_port_cmd + ' flowid 1:1')
            else:
                cmd_list.append(base_command + target_protocol_cmd + ' flowid 1:1')

            # enable fault injection
            if 'random' in fault_pattern:
                if 'delay' in fault_type:
                    # e.g., tc qdisc add dev tap0897f3c6-e0 root netem delay 50ms reorder 50%
                    random_perc = 100 - int(fault_pattern_args)
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + fault_args + ' reorder ' + str(
                            random_perc) + '%')
                else:
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + fault_pattern_args + '%')
            elif 'persistent' in fault_pattern:
                if 'bottleneck' in fault_type:
                    # the command is like: tc qdisc add dev tapa68bfef8-df root tbf rate 256kbit burst 1600 limit 3000
                    default_bottleneck_burst = '1600'
                    default_limit_burst = '3000'
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: tbf rate ' + fault_args + 'kbit burst ' + default_bottleneck_burst + ' limit ' + default_limit_burst)

                else:
                    if 'delay' in fault_type:
                        tc_arg = fault_args
                    else:
                        tc_arg = '100%'

                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + tc_arg)

        else:
            cmd_list = []
            cmd_list.append(
                'nsenter --target ' + str(
                    node_pid) + ' --net  ' + tc_path + '/tc qdisc del dev ' + device + ' root handle 1: prio')

        log.debug("cmd_list generated => %s\n" % cmd_list)

        return cmd_list

    def inject_nics(self, device, node_pid, fault_type, fault_pattern, fault_pattern_args, fault_args, target_traffic,
                    target_protocol, target_dst_ports, target_src_ports, enable):

        # tc/netem commands used to inject fault
        #
        # fault_type = [ delay | loss | corrupt | duplicate | bottleneck | down | reboot]
        # fault_args = [<latency>ms | <percentage>%]
        #
        # DELAY:
        # tc qdisc add dev <nic> root netem delay <latency>ms"
        #
        # LOSS:
        # tc qdisc add dev <nic> root netem loss <percentage>%
        #
        # CORRUPT:
        # tc qdisc change dev <nic> root netem corrupt <percentage>%

        # NOTE: to handle properly floating ip injection we need to filter on floating ip
        #
        # Example:
        #
        # to enable:
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 root handle 1: prio
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc filter add dev qg-a931d750-88 parent 1:0 protocol ip prio 1 u32 match ip src 10.0.20.232 flowid 1:1
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc filter add dev qg-a931d750-88 parent 1:0 protocol ip prio 1 u32 match ip dst 10.0.20.232 flowid 1:1
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 parent 1:1 handle 2: netem delay 1000ms
        #
        # to disable:
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 root handle 1: prio

        # NOTE: if self.getTargetName is not None it means that we are injecting in a floating IP address for virtual networks
        # if self.getTargetName():
        #     log.error("Going down a path removed from ThorFI: Target name. Insert it again to continue")
        #     cmd_list = []

        # NOTE: We are injecting on the other network resources except floating IP
        # if fault target is ANY_TRAFFIC call make_nics_injection_command
        if 'any' in target_traffic:
            # Inject into all protocols
            if enable:
                # enable fault injection
                command = self.make_nics_injection_command(node_pid, device, fault_type, fault_pattern,
                                                           fault_pattern_args[0],
                                                           fault_args, 'add')
            else:
                command = self.make_nics_injection_command(node_pid, device, fault_type, fault_pattern,
                                                           fault_pattern_args[0],
                                                           fault_args, 'del')

            log.debug("Execute command in namespace for process  %s: '%s'\n" % (node_pid, command))
            retcode = call(command, shell=True)
            if retcode < 0:
                log.debug("Command '%s' was terminated not correctly (recode %s)\n" % (command, -retcode))
            else:
                log.debug("Command '%s' was terminated correctly (retcode %s)\n" % (command, retcode))

        # if fault target is not ANY_TRAFFIC generate cmds for injecting according to protocol and port number
        else:
            # Inject into only specific protocols
            cmd_list = []
            if enable:
                cmd_list = self.make_filter_cmds(node_pid, fault_pattern, fault_pattern_args[0], fault_type, fault_args,
                                                 device,
                                                 target_protocol, target_dst_ports, target_src_ports, True)
            else:
                cmd_list = self.make_filter_cmds(node_pid, fault_pattern, fault_pattern_args[0], fault_type, fault_args,
                                                 device,
                                                 target_protocol, target_dst_ports, target_src_ports, False)

            for command in cmd_list:
                log.debug("Execute command in namespace for process %s: '%s'\n" % (node_pid, command))

                retcode = call(command, shell=True)  # TODO call the relevant hosts command instead
                if retcode < 0:
                    log.debug("Command '%s' was terminated not correctly (recode %s)" % (command, -retcode))
                else:
                    log.debug("Command '%s' was terminated correctly (retcode %s)" % (command, retcode))


class NodeInjector:
    def __init__(self,
                 target_process_pid=None,  # This pid represents the "node" we want to run on
                 fault_type=None,  # "stress", custom, ???
                 pre_injection_time=0,
                 injection_time=20,
                 post_injection_time=0,
                 fault_args=None,  # For stress: Percentage. For custom: Start command/end command
                 fault_pattern=None,  # persistent|burst|degradation
                 fault_pattern_args=None
                 # We want mode - for defaults like a CPU stressor, but also custom commands
                 ):
        self.target_process_pid = target_process_pid
        self.fault_type = fault_type
        self.pre_injection_time = pre_injection_time
        self.injection_time = injection_time
        self.post_injection_time = post_injection_time
        self.fault_args = fault_args
        self.fault_pattern = fault_pattern
        self.fault_pattern_args = fault_pattern_args

        if fault_type == "stress_cpu":
            self.cpu_cgroup_name = self._get_cgroup_name()

    async def go(self):
        await self.do_injection()

    def _get_cgroup_name(self):
        pid = self.target_process_pid
        path_to_process_cgroup = f"/proc/{pid}/cgroup"
        cgroup_command = ["/usr/bin/cat", f"{path_to_process_cgroup}"]  # TODO make this binary part of the distribution
        try:
            cgroup_process = subprocess.run(cgroup_command, text=True, capture_output=True)
            cgroup_process.check_returncode()
            cgroup_path = cgroup_process.stdout
            log.debug("cgroups for pid " + str(pid) + ": " + cgroup_path)
            cpu_cgroup_pattern = r"^(\d*):cpu,cpuacct:/(.*)$"
            match = re.search(cpu_cgroup_pattern, cgroup_path, re.MULTILINE)
            cgroup_name = match.group(2)
            return cgroup_name

        except subprocess.CalledProcessError:
            log.error("Can't access cgroups information")
        return None

    def execute_command_for_node(self, pid_of_node, command_to_execute):
        base_command = f"nsenter --target {str(pid_of_node)} --net --pid --all "
        full_command = base_command + command_to_execute
        retcode = call(full_command, shell=True)
        if retcode < 0:
            log.debug("Command '%s' was terminated not correctly (recode %s)\n" % (full_command, -retcode))
        else:
            log.debug("Command '%s' was terminated correctly (retcode %s)\n" % (full_command, retcode))

    def _get_cgroup_size(self):
        size_command = ["/usr/bin/cgget", "-g", "cpu", self.cpu_cgroup_name]
        # TODO make this binary part of the distribution
        try:
            cgroup_process = subprocess.run(size_command, text=True, capture_output=True)
            cgroup_process.check_returncode()
            cpu_cgroup_details = cgroup_process.stdout

            period_regex = r"^cpu\.cfs_period_us: (\d*)$"
            quota_regex = r"^cpu\.cfs_quota_us: (\d*)$"
            cpu_period = re.search(period_regex, cpu_cgroup_details, re.MULTILINE).group(1)
            cpu_quota = re.search(quota_regex, cpu_cgroup_details, re.MULTILINE).group(1)

            cpu_ratio = int(cpu_quota) / int(cpu_period)
            return cpu_ratio
        except subprocess.CalledProcessError:
            log.error("Tried to find cgroup size for " + self.cpu_cgroup_name + ", but couldn't find it\n")
            return None

    async def _inject_burst(self):
        if self.fault_type == 'custom':
            burst_config = self.fault_pattern_args
            burst_duration = int(burst_config[0]) / 1000
            burst_period = int(burst_config[1]) / 1000  # after each burst, wait for (burst_period - burst_duration)
            burst_num = int((self.injection_time) / burst_period)  # how often we burst

            start_command = self.fault_args[0]
            end_command = self.fault_args[1]

            for _ in range(burst_num):
                self.execute_command_for_node(self.target_process_pid, start_command)
                await asyncio.sleep(burst_duration)
                self.execute_command_for_node(self.target_process_pid, end_command)
                await asyncio.sleep(burst_period - burst_duration)

        elif self.fault_type == 'stress_cpu':
            burst_config = self.fault_pattern_args 
            burst_duration = int(max(1, burst_config[0] / 1000))
            burst_period = int(burst_config[1]) / 1000  # after each burst, wait for (burst_period - burst_duration)
            burst_num = int(self.injection_time / burst_period)  # how often we burst

            cgroup_fraction = self._get_cgroup_size()
            cpu_stress_percentage = int(self.fault_args[0])
            stress_percentage_applied_to_cgroup = int(cpu_stress_percentage * cgroup_fraction)

            stress_command = f"stress-ng -l {stress_percentage_applied_to_cgroup} -t {burst_duration} --cpu 1 --cpu-method decimal64"

            for _ in range(burst_num):
                self.execute_command_for_node(self.target_process_pid, stress_command)
                await asyncio.sleep(burst_period - burst_duration)
        # TODO handle else case

    async def _inject_degradation(self):
        if self.fault_type == 'custom':
            start_base_command = self.fault_args[0]
            end_base_command = self.fault_args[1]

            if len(self.fault_args) > 2:
                step_start = int(self.fault_args[2])
            else:
                step_start = 0

            step_size = int(self.fault_pattern_args[0])
            step_duration = int(self.fault_pattern_args[1])

            # TODO verify that {} and number of arguments is the same
            # TODO also skip argument insertaion if
            # TODO expand this to allow for multiple arguments - but later
            test_duration = 0

            injection_intensity = step_start
            while test_duration < self.injection_time:
                start_command = start_base_command.format(injection_intensity)
                end_command = end_base_command

                self.execute_command_for_node(self.target_process_pid, start_command)
                await asyncio.sleep(step_duration)
                self.execute_command_for_node(self.target_process_pid, end_command)

                injection_intensity = injection_intensity + step_size
                test_duration += step_duration
        elif self.fault_type == 'stress_cpu':
            # increment by fault_pattern_args[0] every fault_pattern_args[1]
            cgroup_fraction = self._get_cgroup_size()
            cpu_stress_starting_percentage = int(self.fault_args[0])
            step_size_in_percent = int(self.fault_pattern_args[0])
            stress_step_duration = int(self.fault_pattern_args[1])

            starting_stress_applied_to_cgroup = int(cpu_stress_starting_percentage * cgroup_fraction)
            stress_base_command = "stress-ng -l {} -t {} --cpu 1 --cpu-method decimal64"

            test_duration = 0
            # TODO probably limit to 100%? The other stressers as well
            injection_intensity = starting_stress_applied_to_cgroup
            while test_duration < self.injection_time:
                stress_command = stress_base_command.format(injection_intensity, stress_step_duration)
                self.execute_command_for_node(self.target_process_pid, stress_command)
                injection_intensity = int(injection_intensity + (step_size_in_percent * cgroup_fraction))
                test_duration += stress_step_duration
                # No need to sleep, command runs for as long as indicated
        # TODO handle else case

    async def _inject_static(self):
        # Build up
        if self.fault_type == 'custom':
            duration_in_seconds = self.injection_time

            start_command = self.fault_args[0]
            end_command = self.fault_args[1]
            self.execute_command_for_node(self.target_process_pid, start_command)
            await asyncio.sleep(duration_in_seconds)
            self.execute_command_for_node(self.target_process_pid, end_command)

        elif self.fault_type == 'stress_cpu':
            # inject here
            # Users want n % cpu usage _on a node_ (=cgroup), but the stress-ng takes a global load.
            # To get our in-cpu we reduce the stress instruction by however much cpu is not allowed in our cgroup
            cgroup_fraction = float(self._get_cgroup_size())
            cpu_stress_percentage = float(self.fault_args[0])
            stress_percentage_applied_to_cgroup = int(cpu_stress_percentage * cgroup_fraction)
            duration_in_seconds = self.injection_time
            stress_base_command = f"stress-ng -l {stress_percentage_applied_to_cgroup} -t {duration_in_seconds} --cpu 1 --cpu-method decimal64"
            self.execute_command_for_node(self.target_process_pid, stress_base_command)
            # No need to sleep, command runs for as long as indicated
        # TODO handle else case

    async def do_injection(self):
        # TODO sensible logging downstream from here
        await asyncio.sleep(self.pre_injection_time)
        if self.fault_pattern == 'burst':
            await self._inject_burst()
        elif self.fault_pattern == 'degradation':
            await self._inject_degradation()
        elif self.fault_pattern == 'static':
            await self._inject_static()
        # TODO handle else case

        await asyncio.sleep(self.post_injection_time)
        return
