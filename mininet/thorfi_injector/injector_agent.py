"""
Note: Under  GPL-3.0 license license
Document source from ThorFI
"""
import asyncio
import re
import subprocess

from mininet import log

from subprocess import call

tc_path = '/usr/sbin'  # TODO make this refer to a binary we have in our download

"""Notes:

- Question: How _smart_ is the injector? Specifically, who holds the timer-until-start? Injector, or management agent?
    - Maybe go into phases, and within each phase there's autonomy, but the central controler pushes from phase to phase
    """


class Injector:

    def __init__(self,
                 target_nics=None,  # user-provided. Interfaces, like eth0. Expects a list
                 target_namespace_pid=None,
                 # user-provided, pid of the main node shell we should inject on
                 fault_target_traffic=None,
                 # user-provided, if fault target is not ANY_TRAFFIC generate cmds for injecting according to protocol
                 # and port number
                 fault_target_protocol=None,  # user-provided
                 fault_target_dst_ports=None,  # ???
                 fault_target_src_ports=None,  # ???
                 fault_type=None,  # user-provided, "delay", "persistent", "bottleneck", "down", "deletion", duplicate
                 fault_pattern=None,  # user-provided, "burst", "degradation"
                 fault_pattern_args=None,  # user-provided
                 fault_args=None,  # user-provided: how harsh failure is
                 pre_injection_time=0,  # user-provided, int, time before
                 injection_time=20,  # user-provided  int, time during
                 post_injection_time=0,  # user-provided,  int, time after
                 interface_owner=None):  # use-provided, generated by faultcontroller. Knows how I need to inject
        # into my interface

        # target_nics: is a list of network resources to be injected
        # fault: is the fault to be injected in the network resource
        # time: describe how last the injection

        self.target_nics = target_nics  # TODO change+rename this to contain our interfaces
        self.namespace_pid = target_namespace_pid

        self.fault_target_traffic = fault_target_traffic
        self.fault_target_protocol = fault_target_protocol
        self.fault_target_dst_ports = fault_target_dst_ports
        self.fault_target_src_ports = fault_target_src_ports

        self.fault_type = fault_type
        self.fault_pattern = fault_pattern
        self.fault_pattern_args = fault_pattern_args
        self.fault_args = fault_args

        self.pre_injection_time = pre_injection_time
        self.injection_time = injection_time
        self.post_injection_time = post_injection_time

        # self.target_name = target_name # used to id whether we're injecting into floating IP spaces
        # I don't think we'll ever do that, so I'm removing the relevant code
        self.interface_owner = interface_owner

        self.target_protocol_table = {
            'ICMP': '1',
            'IGMP': '2',
            'IP': '4',
            'TCP': '6',
            'UDP': '17',
            'IPv6': '41',
            'IPv6-ICMP': '58'
        }

    def setTargetNics(self, target_nics):
        self.target_nics = target_nics

    def getTargetInterfaces(self):
        return self.target_nics

    def getFaultTargetTraffic(self):
        return self.fault_target_traffic

    def setFaultTargetTraffic(self, fault_target_traffic):
        self.fault_target_traffic = fault_target_traffic

    def getFaultTargetProtocol(self):
        return self.fault_target_protocol

    def setFaultTargetProtocol(self, fault_target_protocol):
        self.fault_target_protocol = fault_target_protocol

    def getFaultTargetDstPorts(self):
        return self.fault_target_dst_ports

    def setFaultTargetDstPorts(self, fault_target_dst_ports):
        self.fault_target_dst_ports = fault_target_dst_ports

    def getFaultTargetSrcPorts(self):
        return self.fault_target_src_ports

    def setFaultTargetSrcPorts(self, fault_target_src_ports):
        self.fault_target_src_ports = fault_target_src_ports

    def getFaultType(self):

        return self.fault_type

    def getFaultPattern(self):

        return self.fault_pattern

    def setFaultPattern(self, fault_pattern):

        self.fault_pattern = fault_pattern

    def getFaultPatternArgs(self):

        return self.fault_pattern_args

    def setFaultPatternArgs(self, fault_pattern_args):

        self.fault_pattern_args = fault_pattern_args

    def setFaultType(self, fault_type):
        self.fault_type = fault_type

    def getFaultArgs(self):
        return self.fault_args

    def setFaultArgs(self, fault_args):
        self.fault_args = fault_args

    def getPreInjectionTime(self):

        return float(self.pre_injection_time)

    def setPreInjectionTime(self, pre_injection_time):

        self.pre_injection_time = pre_injection_time

    def getInjectionTime(self):

        return float(self.injection_time)

    def setInjectionTime(self, injection_time):

        self.injection_time = injection_time

    def getPostInjectionTime(self):

        return float(self.post_injection_time)

    def setPostInjectionTime(self, post_injection_time):

        self.post_injection_time = post_injection_time

    def getTargetType(self):

        return self.target_type

    def setTargetType(self, target_type):
        self.target_type = target_type

    def create_subnet(self, neutron_client, name, id, netid, cidr, gateway=None):
        log.error("Not currently implemented\n")
        # logger.info("Create subnet resource name: %s id: %s netid: %s cidr: %s gateway: %s" % (name, id, netid, cidr, gateway))
        #
        # resource = 'subnet'
        # args = ['--gateway', gateway, netid, cidr, '--description', 'cave']
        # position_names = ['ip_version', 'network_id', 'cidr', 'gateway_ip']
        # position_values = [4, netid, cidr, gateway]
        #
        # body = { resource : {} }
        # body[resource].update({'name': name})
        # body[resource].update({'ip_version': 4})
        # body[resource].update({'network_id': netid})
        # body[resource].update({'cidr': cidr})
        # body[resource].update({'gateway_ip': gateway})
        #
        # subnet = neutron_client.create_subnet(body)
        # return subnet['subnet']['id']

    def create_network(self, neutron_client, target_net):
        log.error("Not currently implemented\n")

        # logger.info("Create OpenStack network resource '%s'" % target_net)
        # resource = 'network'
        # body = { resource : {} }
        # body[resource].update({'name': target_net})
        #
        # net = neutron_client.create_network(body)
        # net_id = net['network']['id']
        #
        # logger.info("Created network resource wiht id %s" % net_id)
        #
        # return net_id

    def create_router(self, neutron_client, router_name, tenant_id, network_id):
        log.error("Not currently implemented\n")
        # resource = 'router'
        # body = { resource : {} }
        # body[resource].update({'name': router_name})
        # body[resource].update({'tenant_id': tenant_id})
        # body[resource].update({'admin_state_up': True})
        # #body[resource].update({'external_gateway_info': dict(network_id=network_id)})
        #
        # router = neutron_client.create_router(body)
        #
        # return router['router']['id']

    def get_fip_port_mapping(self, neutron_client, port):
        log.error("Not currently implemented\n")
        # public_ips_list = {}
        # fip = None
        #
        #
        # return fip, public_ips_list
        #

    def do_delete_port(self, neutron_client, port):
        log.error("Not currently implemented\n")
        # private_ips_list = []
        # public_ips_list = {}
        # subnet_info = {}
        # router_target = None
        # gateway_info = None
        #
        # #remove before router_interface port
        # logger.info("Removing port of type: %s id: %s" % (port['device_owner'], port['id']))
        # logger.debug("Port details: %s" % port)
        #
        # if port['device_owner'] and (port['device_owner'] in 'network:router_interface' or port['device_owner'] in 'network:router_gateway'):
        #
        #     # In that case, we perform the following:
        #     #       1. detach the linked floating ip on the router port
        #     #       2. remove the port using remove_interface_router
        #     #
        #     # Note that we save information to be restored into 'public_ips_list' variable
        #
        #     router_id = port['device_id']
        #
        #     router_target = router_id
        #     logger.debug("Router target to be used during network restoration is %s" % router_target)
        #
        #     logger.debug("Router ID router_id: %s" % router_id)
        #
        #     # to remove router_interface port we need to remove all floating ips linked to it
        #     logger.debug("In order to remove router_interface port we need to remove all floating ips linked to it")
        #     for floatingips in neutron_client.list_floatingips()['floatingips']:
        #
        #         logger.info("Check for floating ip: %s router_id: %s" % (floatingips['floating_ip_address'], floatingips['router_id']))
        #
        #
        #         if floatingips['router_id'] and router_id in floatingips['router_id']:
        #
        #                 logger.debug("Floating IP %s match with router_id %s!" % (floatingips['floating_ip_address'], router_id))
        #                 logger.info("Disassociate floating ip %s" % floatingips['floating_ip_address'])
        #
        #                 #save in 'public_ips_list' the link between floating ip and private id
        #                 public_ips_list[floatingips['floating_ip_address']] = [ floatingips['id'], floatingips['fixed_ip_address'], floatingips['port_id'], None]
        #
        #                 neutron_client.update_floatingip(floatingips['id'], {'floatingip': {'port_id': None}})
        #
        #
        #     if port['device_owner'] in 'network:router_interface':
        #
        #         # now we can remove the router interface
        #         logger.info("Remove the router interface by identifying the linked subnet through the fixed_ips of the port")
        #         fixed_ips = port['fixed_ips']
        #         subnet_index = 0
        #         for subnet in fixed_ips:
        #
        #             subnet_id = subnet['subnet_id']
        #             subnet_name = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['name']
        #             subnet_cidr = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['cidr']
        #             subnet_gateway_ip = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['gateway_ip']
        #             subnet_info = { 'subnet_id' : subnet_id, 'subnet_name': subnet_name, 'subnet_cidr': subnet_cidr, 'subnet_gateway_ip': subnet_gateway_ip}
        #
        #             logger.debug("Subnet details. id: %s name: %s cidr: %s subnet_gateway_ip: %s" % (subnet_id, subnet_name, subnet_cidr, subnet_gateway_ip))
        #             logger.info("Remove from subnet %s the gateway interface linked to router %s" % (subnet['subnet_id'], router_id))
        #
        #             neutron_client.remove_interface_router(router_id, {"subnet_id" : subnet['subnet_id'] } )
        #
        #     elif port['device_owner'] in 'network:router_gateway':
        #
        #         logger.info("Remove the gateway of router '%s'" % router_id)
        #
        #         #gateway info is of type: {"network_id": "2b85be5d-4ab4-468a-83ff-0ecf6def2385", "external_fixed_ips": [{"ip_address": "172.24.4.9"}]}
        #         gateway_info = {'network_id' : port['network_id'], 'external_fixed_ips': [{'ip_address': port['fixed_ips'][0]['ip_address']}]}
        #
        #         logger.info("Saved info for restoring: %s" % gateway_info)
        #
        #         # remove the router gateway...save network_id and fixed_ips[0]['ip_address'] for restoring
        #         neutron_client.remove_gateway_router(router_id)
        #         await asyncio.sleep(1)
        #
        #
        # else:
        # # remove other types of ports
        # #for port in ports_net['ports']:
        #
        #     ip = None
        #
        #     #if port['device_owner'] and port['device_owner'] not in 'network:router_interface':
        #
        #     # we can delete the port simply by calling 'delete_port' api, but before
        #     # we need to save the private ip of an instance (in that case the 'device_owner' is 'compute:nova', and the instance id (i.e., device_id value)
        #     # in order to restore it after network deletion
        #
        #     if port['device_owner'] in 'compute:nova':
        #
        #         ip = port['fixed_ips'][0]['ip_address']
        #         subnet_id = port['fixed_ips'][0]['subnet_id']
        #         network_id = port['network_id']
        #
        #         private_ips_list.append( {
        #                                     ip :
        #                                         {
        #                                             'instance_id' : port['device_id'],
        #                                             'subnet_id' : subnet_id,
        #                                             'network_id' : network_id
        #                                         }
        #                                   }
        #                                 )
        #
        #         #check if that port is linked to a floating ip
        #
        #         fip = neutron_client.list_floatingips(port_id=port['id'])['floatingips'][0]
        #         if fip:
        #             public_ips_list[fip['floating_ip_address']] = [ fip['id'], fip['fixed_ip_address'], fip['port_id'], None]
        #
        #         logger.info("Removing port id %s => %s" % (port['id'], ip))
        #         neutron_client.delete_port(port['id'])
        #
        #     elif port['device_owner'] in 'network:floatingip':
        #
        #         # get the fip linked to the target port and then invoke delete_floatingip API
        #
        #         fip_address = neutron_client.list_ports(id=port['id'])['ports'][0]['fixed_ips'][0]['ip_address']
        #         if fip_address:
        #
        #             fip = neutron_client.list_floatingips(floating_ip_address=fip_address)['floatingips'][0]
        #
        #             public_ips_list[fip['floating_ip_address']] = [ None, fip['fixed_ip_address'], fip['port_id'], fip['floating_network_id'] ]
        #
        #         logger.info("Removing port id %s => %s" % (port['id'], fip_address))
        #         neutron_client.delete_floatingip(fip['id'])
        #
        # return private_ips_list, public_ips_list, subnet_info, router_target, gateway_info

    def do_delete_network_ports(self, neutron_client, ports_net):
        log.error("Not currently implemented\n")
        #
        # private_ips_list = []
        # public_ips_list = {}
        # subnet_info = {}
        # router_target = None
        #
        # #remove before router_interface port
        # for port in ports_net['ports']:
        #
        #     await asyncio.sleep(1)
        #
        #     #TODO: we need to handle the case of multiple router_interface!!!
        #
        #     if port['device_owner'] and port['device_owner'] in 'network:router_interface':
        #
        #
        #         logger.info("Removing port with id: %s" % port['id'])
        #         logger.debug("Port details: %s" % port)
        #
        #
        #         logger.debug("Port owner is network:router_interface!")
        #         # In that case, we perform the following:
        #         #       1. detach the linked floating ip on the router port
        #         #       2. remove the port using remove_interface_router
        #
        #         router_id = port['device_id']
        #
        #         router_target = router_id
        #         logger.debug("Router target to be used during network restoration is %s" % router_target)
        #
        #         logger.debug("Router ID router_id: %s" % router_id)
        #
        #         # to remove router_interface port we need to remove all floating ips linked to it
        #         logger.debug("In order to remove router_interface port we need to remove all floating ips linked to it")
        #         for floatingips in neutron_client.list_floatingips()['floatingips']:
        #
        #             logger.info("Check for floating ip: %s router_id: %s" % (floatingips['floating_ip_address'], floatingips['router_id']))
        #
        #
        #             if floatingips['router_id'] and router_id in floatingips['router_id']:
        #
        #                     logger.debug("Floating IP %s match with router_id %s!" % (floatingips['floating_ip_address'], router_id))
        #                     logger.info("Disassociate floating ip %s" % floatingips['floating_ip_address'])
        #
        #                     #save in 'public_ips_list' the link between floating ip and private id
        #                     public_ips_list[floatingips['floating_ip_address']] = [ floatingips['id'], floatingips['fixed_ip_address'], floatingips['port_id']]
        #
        #                     neutron_client.update_floatingip(floatingips['id'], {'floatingip': {'port_id': None}})
        #
        #
        #         # now we can remove the router interface
        #         logger.info("Remove the router interface by identifying the linked subnet through the fixed_ips of the port")
        #         fixed_ips = port['fixed_ips']
        #         subnet_index = 0
        #         for subnet in fixed_ips:
        #
        #             subnet_id = subnet['subnet_id']
        #             subnet_name = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['name']
        #             subnet_cidr = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['cidr']
        #             subnet_gateway_ip = neutron_client.list_subnets(id=subnet_id)['subnets'][subnet_index]['gateway_ip']
        #             subnet_info = { 'subnet_name': subnet_name, 'subnet_cidr': subnet_cidr, 'subnet_gateway_ip': subnet_gateway_ip}
        #
        #             logger.debug("Subnet details. id: %s name: %s cidr: %s subnet_gateway_ip: %s" % (subnet_id, subnet_name, subnet_cidr, subnet_gateway_ip))
        #             logger.info("Remove from subnet %s the gateway interface linked to router %s" % (subnet['subnet_id'], router_id))
        #             neutron_client.remove_interface_router(router_id, {"subnet_id" : subnet['subnet_id'] } )
        #
        # # remove other types of ports
        # for port in ports_net['ports']:
        #
        #     logger.info("Removing port with id: %s" % port['id'])
        #     logger.debug("Port details: %s" % port)
        #
        #     if port['device_owner'] and port['device_owner'] not in 'network:router_interface':
        #
        #         # we can delete the port simply by calling 'delete_port' api, but before
        #         # we need to save the private ip of an instance (in that case the 'device_owner' is 'compute:nova'
        #         # in order to restore it after network deletion
        #
        #         ip = None
        #         fixed_ips = port['fixed_ips']
        #         for subnet in fixed_ips:
        #             ip = subnet['ip_address']
        #
        #         if port['device_owner'] in 'compute:nova':
        #             private_ips_list.append(ip)
        #
        #         logger.info("Remove port id %s => %s" % (port['id'], ip))
        #         neutron_client.delete_port(port['id'])
        #
        #     elif not port['device_owner']:
        #
        #         neutron_client.delete_port(port['id'])
        #
        # return private_ips_list, public_ips_list, subnet_info, router_target

    def do_delete_router(self, neutron_client, router_id):
        log.error("Not currently implemented\n")
        # ret_list = []
        # #create ordered list of port so that we remove firstly router interface and then gateway
        #
        # for port in neutron_client.list_ports(device_id=router_id)['ports']:
        #     #delete port
        #     private_ips_list, public_ips_list, subnet_info, router_target, gateway_info = self.do_delete_port(neutron_client, port)
        #     ret_list.append(
        #                       {
        #                       'old_port_id' : port['id'],
        #                       'private_ips_list' : private_ips_list,
        #                       'public_ips_list' : public_ips_list,
        #                       'subnet_info' : subnet_info,
        #                       'router_target' : router_target,
        #                       'gateway_info' : gateway_info
        #                       }
        #                     )
        #
        # neutron_client.delete_router(router_id)
        #
        # return ret_list

    def restore_fips(self, neutron_client, public_ips_list, restored_port_id):
        log.error("Not currently implemented\n")
        # attach_max_retry = 20
        # logger.info("Restoring floating ips linked to previous ports...")
        # #restore public ip
        # for public_ip, fip_mapping in public_ips_list.items():
        #
        #     #instance = instances_ips[public_ip]
        #     #logger.info("Attaching floating IP %s at instance %s" % (public_ip, instance))
        #
        #     fip_id = None
        #     fip_fixed_ip_address = fip_mapping[1]
        #
        #     public_net_id = fip_mapping[3]
        #     if public_net_id:
        #         fip = neutron_client.create_floatingip({ 'floatingip': {'floating_ip_address': public_ip, 'floating_network_id' : public_net_id} })
        #         fip_id = fip['floatingip']['id']
        #         #TODO: gestire una lista di floating ip creati!!!!
        #         restored_fip_id = fip_id
        #
        #     if not fip_id:
        #         logger.info("We use old fip_id '%s' because we did not removed it" % (fip_mapping[0]))
        #         fip_id = fip_mapping[0]
        #
        #     if not restored_port_id:
        #         logger.info("We do not recreate a private port before because we did not removed!!!...use old port %s to restore the floating ip '%s'" % (fip_mapping[2], public_ip))
        #         neutron_client.update_floatingip(fip_id, {'floatingip': {'port_id': fip_mapping[2]}})
        #     else:
        #         neutron_client.update_floatingip(fip_id, {'floatingip': {'port_id': restored_port_id}})
        #
        #     await asyncio.sleep(3)
        #
        #     #check if re-attached floating ip is reachable...in case detach/attach again the private port
        #     logger.info("Let's try pinging public ip %s" % public_ip)
        #
        #     count_attach = 1
        #
        #     while count_attach <= attach_max_retry:
        #
        #         if not check_reachability(public_ip, 10):
        #
        #             await asyncio.sleep(10)
        #
        #             count_attach += 1
        #         else:
        #
        #             logger.info("Ping check on ip %s done!" % public_ip)
        #             break
        #
        #     if count_attach > attach_max_retry:
        #         logger.error("ThorFI can not ping IP %s. The interface can not be UP for some reasons" % public_ip)
        #         raise Exception
        #
        #     #check ssh connection
        #     ssh_max_retry = 10
        #     count_ssh = 1
        #     while count_ssh <= ssh_max_retry:
        #
        #         logger.warning("Try to establish ssh session on ip %s (retry %s)" % (public_ip, count_ssh))
        #         ssh_session = ssh_connect(public_ip, 'thorfi', injector_agent_path + '/thorfi.key')
        #         if not ssh_session:
        #             count_ssh += 1
        #             await asyncio.sleep(1)
        #
        #         else:
        #
        #             logger.info("SSH check on ip %s done!" % public_ip)
        #             break
        #
        #     if count_ssh > ssh_max_retry:
        #         logger.error("ThorFI can not establish SSH session using IP %s" % public_ip)
        #         raise Exception

    def do_restore_router(self, neutron_client, router_restore_list, router_name, router_project_id,
                          router_public_net_id):
        log.error("Not currently implemented\n")
        # restored_port_list = []
        #
        # restored_router_id = self.create_router(neutron_client, router_name, router_project_id, router_public_net_id)
        #
        # # for each restore element in 'router_restore_list' invoke do_restore_port
        #
        # logger.info("Restoring port '%s'" % port_to_restore)
        # for port_to_restore in router_restore_list:
        #
        #         restored_port_id, router_interface_id, gateway_port_id = self.do_restore_port(
        #                                                                                         self.getNovaClient(),
        #                                                                                         neutron_client,
        #                                                                                         port_to_restore['private_ips_list'],
        #                                                                                         port_to_restore['public_ips_list'],
        #                                                                                         port_to_restore['subnet_info'],
        #                                                                                         restored_router_id,
        #                                                                                         port_to_restore['gateway_info'],
        #                                                                                         False
        #                                                                                       )
        #         restored_port_list.append({ port_to_restore['old_port_id'] : [restored_port_id, router_interface_id, gateway_port_id]})
        #         logger.info("Port '%s' RESTORED! (details: %s)" % port_to_restore)
        #         await asyncio.sleep(5)
        #
        # #NOTE: to restore router ports we need to restore all gateway and router interface and THEN public ip list
        #
        # #restore fips
        # for port_to_restore in router_restore_list:
        #     self.restore_fips(neutron_client, port_to_restore['public_ips_list'], None)
        #
        # return restored_router_id, restored_port_list

    def do_delete_network(self, neutron_client, nova_client, net_id):
        """
            do_delete_network performs deletion of OpenStack network resource with id 'network_id'

        """
        log.error("Not currently implemented\n")

        # ports_net = neutron_client.list_ports(network_id=net_id)
        # private_ips_list = []
        # public_ips_list = {}
        # instances_ips = {}
        #
        # for instance in  nova_client.servers.list():
        #
        #     networks = instance.networks
        #     for name, ips in networks.items():
        #
        #       for ip in ips:
        #           instances_ips[ip] = instance
        #
        # private_ips_list, public_ips_list, subnet_info, router_target = self.do_delete_network_ports(neutron_client, ports_net)
        #
        # net_name = neutron_client.list_networks(id=net_id)['networks'][0]['name']
        # neutron_client.delete_network(net_id)
        # logger.info("Delete network '%s' with id %s" % (net_name, net_id) )
        #
        # return private_ips_list, public_ips_list, instances_ips, subnet_info, router_target, net_name

    def check_interface_status(self, neutron_client, port_id, status, attach_max_retry):
        log.error("Not currently implemented\n")
        # count_attach = 1
        # while neutron_client.list_ports(id=port_id)['ports'][0]['status'] not in status and count_attach <= attach_max_retry:
        #     logger.debug("Wait for port '%s' to be %s" % (port_id, status))
        #     await asyncio.sleep(1)
        #     count_attach += 1
        #
        # if count_attach <= attach_max_retry:
        #     return True
        # else:
        #     return False

    def check_network_status(self, neutron_client, net_id, status, max_retry):
        log.error("Not currently implemented\n")
        #
        # count = 1
        # while neutron_client.list_networks(id=net_id)['networks'][0]['status'] not in status and count <= max_retry:
        #     logger.debug("Wait for port '%s' to be %s" % (port_id, status))
        #     await asyncio.sleep(1)
        #     count += 1
        #
        # if count <= max_retry:
        #     return True
        # else:
        #     return False

    def do_restore_port(self, nova_client, neutron_client, private_ips_list, public_ips_list, subnet_info,
                        router_target, gateway_info, fip_restore=True):
        log.error("Not currently implemented\n")

        # logger.info("Port resource restore start...")
        #
        # restored_port_id = None
        # router_interface_id = None
        # gateway_port_id = None
        #
        # if subnet_info:
        #     subnet_id = subnet_info['subnet_id']
        #
        # # if port was a router interface we need to add an interface router on 'router_target' for subnet 'subnet_id'
        # if router_target and not gateway_info:
        #     logger.info("Restore router interface with subnet %s" % subnet_id)
        #     router_interface = neutron_client.add_interface_router(router_target, {'subnet_id' : subnet_id})
        #     router_interface_id = router_interface['port_id']
        #
        # # if port was a router gateway we need to add gateway router on 'router_target' with 'gateway_info'
        # elif router_target and gateway_info:
        #     logger.info("Restore router gateway interface with gateway_info %s" % gateway_info)
        #     gateway_port = neutron_client.add_gateway_router(router_target, gateway_info)
        #
        #     for router_port in neutron_client.list_ports(device_id=gateway_port['router']['id'])['ports']:
        #         if 'network:router_gateway' in router_port['device_owner']:
        #             gateway_port_id = router_port['id']
        #             break
        #     logger.info("Restored router gateway interface with port id: %s" % gateway_port_id)
        #
        # await asyncio.sleep(5)
        #
        # logger.info("Private ip list to restore: %s" % private_ips_list)
        # logger.info("Public ip dict to restore: %s" % public_ips_list)
        #
        # attach_max_retry = 20
        #
        # #restore private
        # #for private_ip, instance_id in private_ips_list.items():
        # for ipspec in private_ips_list:
        #
        #     for private_ip, port_info in ipspec.items():
        #
        #         #instance = instances_ips[private_ip]
        #         instance_id = port_info['instance_id']
        #         subnet_id = port_info['subnet_id']
        #         net_id = port_info['network_id']
        #
        #         logger.info("Attaching interface with IP '%s' at instance: '%s'; subnet: '%s'; network: '%s'" % (private_ip, instance_id, subnet_id, net_id))
        #
        #         #create a port with neutron
        #         port_body_value = {
        #                         "port": {
        #                             "admin_state_up": True,
        #                             "fixed_ips": [{"subnet_id": subnet_id, "ip_address": private_ip}],
        #                             "network_id": net_id
        #                         }
        #                       }
        #
        #         #create port for the instance interface
        #         logger.debug("Creating port with configuration: %s" % port_body_value)
        #         port_to_add = neutron_client.create_port(body=port_body_value)
        #         restored_port_id = port_to_add['port']['id']
        #         await asyncio.sleep(5)
        #
        #         #attach the port with the instance
        #         nova_client.servers.interface_attach(instance_id, port_id=restored_port_id, net_id=None, fixed_ip=None)
        #
        #         if not self.check_interface_status(neutron_client, restored_port_id, 'ACTIVE', attach_max_retry):
        #             logger.info("Interface %s does not transit in status ACTIVE within %s retries" % (private_ip, attach_max_retry))
        #             raise Exception
        #         else:
        #             logger.info("Interface %s transit in status ACTIVE" % private_ip)
        #
        # logger.info("Wait before attaching floating IP...")
        # await asyncio.sleep(15)
        #
        # if fip_restore:
        #
        #     #restore public ip
        #     for public_ip, fip_mapping in public_ips_list.items():
        #
        #         #instance = instances_ips[public_ip]
        #         #logger.info("Attaching floating IP %s at instance %s" % (public_ip, instance))
        #
        #         fip_id = None
        #         fip_fixed_ip_address = fip_mapping[1]
        #
        #         public_net_id = fip_mapping[3]
        #         if public_net_id:
        #             fip = neutron_client.create_floatingip({ 'floatingip': {'floating_ip_address': public_ip, 'floating_network_id' : public_net_id} })
        #             fip_id = fip['floatingip']['id']
        #             #TODO: gestire una lista di floating ip creati!!!!
        #             restored_fip_id = fip_id
        #
        #         if not fip_id:
        #             logger.info("We use old fip_id '%s' because we did not removed it" % (fip_mapping[0]))
        #             fip_id = fip_mapping[0]
        #
        #         if not restored_port_id:
        #             logger.info("We do not recreate a private port before because we did not removed!!!...use old port %s to restore the floating ip '%s'" % (fip_mapping[2], public_ip))
        #             neutron_client.update_floatingip(fip_id, {'floatingip': {'port_id': fip_mapping[2]}})
        #         else:
        #             neutron_client.update_floatingip(fip_id, {'floatingip': {'port_id': restored_port_id}})
        #
        #         await asyncio.sleep(3)
        #
        #         #check if re-attached floating ip is reachable...in case detach/attach again the private port
        #         logger.info("Let's try pinging public ip %s" % public_ip)
        #
        #         count_attach = 1
        #
        #         while count_attach <= attach_max_retry:
        #
        #             if not check_reachability(public_ip, 10):
        #
        #                 await asyncio.sleep(10)
        #
        #                 count_attach += 1
        #             else:
        #
        #                 logger.info("Ping check on ip %s done!" % public_ip)
        #                 break
        #
        #         if count_attach > attach_max_retry:
        #             logger.error("ThorFI can not ping IP %s. The interface can not be UP for some reasons" % public_ip)
        #             raise Exception
        #
        #         #check ssh connection
        #         ssh_max_retry = 10
        #         count_ssh = 1
        #         while count_ssh <= ssh_max_retry:
        #
        #             logger.warning("Try to establish ssh session on ip %s (retry %s)" % (public_ip, count_ssh))
        #             ssh_session = ssh_connect(public_ip, 'thorfi', injector_agent_path + '/thorfi.key')
        #             if not ssh_session:
        #                 count_ssh += 1
        #                 await asyncio.sleep(1)
        #
        #             else:
        #
        #                 logger.info("SSH check on ip %s done!" % public_ip)
        #                 break
        #
        #         if count_ssh > ssh_max_retry:
        #             logger.error("ThorFI can not establish SSH session using IP %s" % public_ip)
        #             raise Exception
        #
        #
        # logger.info("Port resource restoration completed!")
        # logger.info("restored_port_id: '%s' router_interface_id: '%s' gateway_port_id: '%s'" % (restored_port_id, router_interface_id, gateway_port_id))
        #
        # return restored_port_id, router_interface_id, gateway_port_id

    def do_restore_network(self, nova_client, neutron_client, target_net, subnet_info, router_target, private_ips_list,
                           public_ips_list, instances_ips):
        log.error("Not currently implemented\n")

        # logger.info("Network resource restore start...")
        #
        # subnet_name = subnet_info['subnet_name']
        # subnet_cidr = subnet_info['subnet_cidr']
        # subnet_gateway_ip = subnet_info['subnet_gateway_ip']
        #
        # net_create_max_retry = 10
        # net_id = self.create_network(neutron_client, target_net)
        #
        # await asyncio.sleep(5)
        #
        # if not self.check_network_status(neutron_client, net_id, 'ACTIVE', net_create_max_retry):
        #     logger.error("Network %s does not transit in status ACTIVE within %s retries" % (target_net, net_create_max_retry))
        #     raise Exception
        # else:
        #     logger.info("Network '%s' transit in status ACTIVE" % target_net)
        #
        # subnet_id = self.create_subnet(neutron_client, subnet_name, '', net_id, subnet_cidr, subnet_gateway_ip)
        # await asyncio.sleep(5)
        #
        # if router_target:
        #     logger.info("Create router interface with subnet %s" % subnet_id)
        #     neutron_client.add_interface_router(router_target, {'subnet_id' : subnet_id})
        #
        # await asyncio.sleep(5)
        #
        # logger.info("Private ip list to restore: %s" % private_ips_list)
        # logger.info("Public ip dict to restore: %s" % public_ips_list)
        #
        # attach_max_retry = 20
        #
        # #restore private
        # for private_ip in private_ips_list:
        #
        #     instance = instances_ips[private_ip]
        #     logger.info("Attaching interface with IP %s at instance %s" % (private_ip, instance))
        #
        #     #create a port with neutron
        #     port_body_value = {
        #                     "port": {
        #                         "admin_state_up": True,
        #                         "fixed_ips": [{"subnet_id": subnet_id, "ip_address": private_ip}],
        #                         "network_id": net_id
        #                     }
        #                   }
        #
        #     #create port for the instance interface
        #     logger.debug("Creating port with configuration: %s" % port_body_value)
        #     port_to_add = neutron_client.create_port(body=port_body_value)
        #
        #     await asyncio.sleep(5)
        #
        #     #attach the port with the instance
        #     nova_client.servers.interface_attach(instance.id, port_id=port_to_add['port']['id'], net_id=None, fixed_ip=None)
        #
        #     if not self.check_interface_status(neutron_client, port_to_add['port']['id'], 'ACTIVE', attach_max_retry):
        #         logger.info("Interface %s does not transit in status ACTIVE within %s retries" % (private_ip, attach_max_retry))
        #         raise Exception
        #     else:
        #         logger.info("Interface %s transit in status ACTIVE" % private_ip)
        #
        # logger.info("Wait before attaching floating IP...")
        # await asyncio.sleep(15)
        #
        # #restore public ip
        # for public_ip, fip_mapping in public_ips_list.items():
        #
        #     instance = instances_ips[public_ip]
        #     logger.info("Attaching floating IP %s at instance %s" % (public_ip, instance))
        #     fip_id = fip_mapping[0]
        #     fip_fixed_ip_address = fip_mapping[1]
        #
        #     neutron_client.update_floatingip(fip_id, {'floatingip': {'port_id': port_to_add['port']['id']}})
        #
        #     await asyncio.sleep(3)
        #
        #     #check if re-attached floating ip is reachable...in case detach/attach again the private port
        #     logger.info("Let's try pinging public ip %s" % public_ip)
        #
        #     count_attach = 1
        #
        #     while count_attach <= attach_max_retry:
        #
        #         if not check_reachability(public_ip, 10):
        #
        #             logger.warning("During network '%s' restoration the interface with ip %s does not go up!!!!!" % (target_net, private_ip))
        #
        #             logger.info("Try (%s) to attach/detach again the port %s" % ( count_attach, port_to_add['port']['id']))
        #
        #             nova_client.servers.interface_detach(instance.id, port_to_add['port']['id'])
        #
        #             if not self.check_interface_status(neutron_client, port_to_add['port']['id'], 'DOWN', attach_max_retry):
        #                 logger.info("Interface %s does not transit in status DOWN within %s retries" % (private_ip, attach_max_retry))
        #                 raise Exception
        #             else:
        #                 logger.info("Interface %s transit in status DOWN" % private_ip)
        #
        #             await asyncio.sleep(2)
        #
        #             logger.info("Attach interface port '%s' at instance '%s'" % (port_to_add['port']['id'], instance.id))
        #             nova_client.servers.interface_attach(instance.id, port_id=port_to_add['port']['id'], net_id=None, fixed_ip=None)
        #
        #             if not self.check_interface_status(neutron_client, port_to_add['port']['id'], 'ACTIVE', attach_max_retry):
        #                 logger.info("Interface %s does not transit in status ACTIVE within %s retries" % (private_ip, attach_max_retry))
        #                 raise Exception
        #             else:
        #                 logger.info("Interface %s transit in status ACTIVE" % private_ip)
        #
        #             await asyncio.sleep(10)
        #
        #             count_attach += 1
        #         else:
        #
        #             logger.info("Ping check on ip %s done!" % public_ip)
        #             break
        #
        #     if count_attach > attach_max_retry:
        #         logger.error("ThorFI can not ping IP %s. The interface can not be UP for some reasons" % public_ip)
        #         raise Exception
        #
        #     #check ssh connection
        #     ssh_max_retry = 10
        #     count_ssh = 1
        #     while count_ssh <= ssh_max_retry:
        #
        #         logger.warning("Try to establish ssh session on ip %s (retry %s)" % (public_ip, count_ssh))
        #         ssh_session = ssh_connect(public_ip, 'thorfi', injector_agent_path + '/thorfi.key')
        #         if not ssh_session:
        #             count_ssh += 1
        #             await asyncio.sleep(1)
        #
        #         else:
        #
        #             logger.info("SSH check on ip %s done!" % public_ip)
        #             break
        #
        #     if count_ssh > ssh_max_retry:
        #         logger.error("ThorFI can not establish SSH session using IP %s" % public_ip)
        #         raise Exception
        #
        #
        # logger.info("Network resource '%s' restoration completed!" % target_net)
        #
        # return net_id

    async def _inject_reboot(self):
        log.error("Not implemented - since definition of 'reboot' is non-obvious in our context\n")  # TODO
        log.error("Implement after done with others\n")
        #
        # process = subprocess.Popen('reboot -n -f', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        # # adie' :D
        # return

    async def _inject_burst(self):
        burst_config = self.getFaultPatternArgs()
        burst_duration = float(burst_config[0]) / 1000
        burst_period = float(burst_config[1]) / 1000

        log.info("injection time : %s\n" % self.getInjectionTime())
        burst_num = int((self.getInjectionTime()) / burst_period)

        log.info("Burst config: burst_duration: %s burst_period: %s burst_num: %s\n" % (
            burst_duration, burst_period, burst_num))

        for i in range(burst_num):


            # iterate over all target devices to enable injection
            for interface in self.getTargetInterfaces():
                log.debug("BURST ENABLE injection on nic %s\n" % (interface))
                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'persistent', [''],
                                 self.getFaultArgs(),
                                 self.getFaultTargetTraffic(), self.getFaultTargetProtocol(),
                                 self.getFaultTargetDstPorts(), self.getFaultTargetSrcPorts(), True)

            log.debug("WAIT BURST DURATION...%s\n" % burst_duration)
            await asyncio.sleep(burst_duration)

            for interface in self.getTargetInterfaces():
                log.debug("BURST DISABLE injection on nic %s \n" % interface)
                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'persistent', [''],
                                 self.getFaultArgs(),
                                 self.getFaultTargetTraffic(), self.getFaultTargetProtocol(),
                                 self.getFaultTargetDstPorts(), self.getFaultTargetSrcPorts(), False)

            log.debug("WAIT BURST remaining time...%s\n" % (burst_period - burst_duration))
            await asyncio.sleep(burst_period - burst_duration)

    async def _inject_degradation(self):
        # increment for 'fault_pattern_args' each second
        degradation_step = 1
        degradation_config = self.getFaultPatternArgs()
        degradation_value = degradation_config[0]

        log.info("Degradation fault pattern!!!! Start with %s perc/s\n" % degradation_value)

        for i in range(int(self.getInjectionTime())):

            log.info("#%s step..." % i)
            # iterate over all target devices to enable injection
            for interface in self.getTargetInterfaces():
                log.debug("DEGRADATION ENABLE injection on nic %s \n" % (interface))

                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'random', [degradation_value],
                                 self.getFaultArgs(), self.getFaultTargetTraffic(),
                                 self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                                 self.getFaultTargetSrcPorts(), True)

            log.debug("WAIT DEGRADATION DURATION...%s\n" % degradation_step)
            await asyncio.sleep(degradation_step)

            for interface in self.getTargetInterfaces():
                log.debug("DEGRADATION DISABLE injection on nic %s\n" % interface)
                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), 'random', [degradation_value],
                                 self.getFaultArgs(), self.getFaultTargetTraffic(),
                                 self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                                 self.getFaultTargetSrcPorts(), False)

            degradation_value = str(int(degradation_value) + int(degradation_config[0]))
            if int(degradation_value) > 100:
                degradation_value = str(100)

            log.debug("updated degradation value %s\n" % degradation_value)

    async def _inject_default(self):
        if 'delete' in self.getFaultType():
            log.error("'delete' currently not implemented. This may or may not be done differently\n")  # TODO
            log.error("Implement after done with others\n")
            # if 'network' in self.getTargetType():
            #
            #     net_id = None
            #     restored_resources = None
            #
            #     for net in neutron_client.list_networks()['networks']:
            #
            #         if net['id'] in self.getTargetName():
            #             net_id = net['id']
            #             break
            #
            #     logger.debug("Enable injection deletion on network '%s'" % self.getTargetName())
            #     private_ips_list, public_ips_list, instances_ips, subnet_info, router_target, net_name = self.do_delete_network(
            #         neutron_client, self.getNovaClient(), net_id)
            #
            # elif 'port' in self.getTargetType():
            #
            #     port_id = self.getTargetName()
            #     target_port = neutron_client.list_ports(id=port_id)['ports'][0]
            #     print
            #     target_port
            #     private_ips_list, public_ips_list, subnet_info, router_target, gateway_info = self.do_delete_port(
            #         neutron_client, target_port)
            #     print
            #     private_ips_list, public_ips_list, subnet_info, router_target, gateway_info
            #
            # elif 'router' in self.getTargetType():
            #
            #     router_id = self.getTargetName()
            #
            #     router_name = neutron_client.list_routers(id=router_id)['routers'][0]['name']
            #     router_project_id = neutron_client.list_routers(id=router_id)['routers'][0]['project_id']
            #     router_public_net_id = neutron_client.list_routers(id=router_id)['routers'][0]['external_gateway_info'][
            #         'network_id']
            #
            #     router_restore_list = self.do_delete_router(neutron_client, router_id)
            #
            #     logger.debug("router_restore_list: %s" % router_restore_list)

        else:

            # iterate over all target devices to enable injection
            for interface in self.getTargetInterfaces():
                log.debug("Enable injection on nic %s\n" % (interface))

                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), self.getFaultPattern(),
                                 self.getFaultPatternArgs(), self.getFaultArgs(), self.getFaultTargetTraffic(),
                                 self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                                 self.getFaultTargetSrcPorts(), True)

        log.info("Wait the injection time (%s s)\n" % self.getInjectionTime())
        await asyncio.sleep(self.getInjectionTime())

        if 'delete' in self.getFaultType():
            log.error(
                "First recovery from 'delete' currently not implemented. This may or may not be done differently\n")  # TODO
            log.error("Implement after done with others\n")
            #
            # log.debug("Disable injection deletion on '%s' '%s'" % (self.getTargetType(), self.getTargetName()))
            #
            # if 'network' in self.getTargetType():
            #
            #     restored_resources = self.do_restore_network(self.getNovaClient(), self.getNeutronClient(), net_name,
            #                                                  subnet_info, router_target, private_ips_list,
            #                                                  public_ips_list, instances_ips)
            #
            # elif 'port' in self.getTargetType():
            #
            #     restored_port_id, router_interface_id, gateway_port_id = self.do_restore_port(self.getNovaClient(),
            #                                                                                   self.getNeutronClient(),
            #                                                                                   private_ips_list,
            #                                                                                   public_ips_list,
            #                                                                                   subnet_info,
            #                                                                                   router_target,
            #                                                                                   gateway_info)
            #
            # elif 'router' in self.getTargetType():
            #
            #     restored_router_id, restored_port_list = self.do_restore_router(self.getNeutronClient(),
            #                                                                     router_restore_list, router_name,
            #                                                                     router_project_id, router_public_net_id)
            #
            #     logger.debug("restored_port_list >>>>>>>>>>>>>> %s" % restored_port_list)

        else:

            # iterate over all target devices to disable injection
            for interface in self.getTargetInterfaces():
                log.debug("Disable injection on nic %s\n" % (interface))

                self.inject_nics(interface, self.namespace_pid, self.getFaultType(), self.getFaultPattern(),
                                 self.getFaultPatternArgs(), self.getFaultArgs(), self.getFaultTargetTraffic(),
                                 self.getFaultTargetProtocol(), self.getFaultTargetDstPorts(),
                                 self.getFaultTargetSrcPorts(), False)

    async def _recover_from_delete(self):
        log.error(
            "Second recovery from 'delete' currently not implemented. This may or may not be done differently\n")  # TODO
        log.error("Implement after done with others\n")
        # if 'network' in self.getTargetType():
        #
        #     return [{net_id: restored_resources}]
        #
        # elif 'port' in self.getTargetType():
        #
        #     res = (restored_port_id, router_interface_id, gateway_port_id)
        #     restored = [port for port in res if port]
        #     return [{self.getTargetName(): restored[0]}]
        #
        # elif 'router' in self.getTargetType():
        #
        #     restored_old_new_port = []
        #     # get pair old_port_id : new_port_id
        #     for port_info in restored_port_list:
        #
        #         for old_port_id, restored_info in port_info.items():
        #             restored = [port for port in tuple(restored_info) if port]
        #
        #             restored_old_new_port.append({old_port_id: restored[0]})
        #
        #     restored_old_new_port.append({self.getTargetName(): restored_router_id})
        #
        #     return restored_old_new_port
        #     # logger.debug("restored_old_new_port LIST : %s" % restored_old_new_port)

    async def go(self):
        await self.do_injection()

    async def do_injection(self):

        # if the fault type is reboot, just use subprocess to reboot the node
        if 'reboot' in self.getFaultType():
            await self._inject_reboot()

        # router_name = None
        # net_name = None
        # neutron_client = self.getNeutronClient()

        log.debug("Wait %s s of pre-injection time\n" % self.getPreInjectionTime())
        # wait 'self.pre_injection_time' before injection
        await asyncio.sleep(self.getPreInjectionTime())

        if 'burst' in self.getFaultPattern():
            await self._inject_burst()
        elif 'degradation' in self.getFaultPattern():
            await self._inject_degradation()

        else:
            await self._inject_default()

        ################ END INJECTION CODE ###################

        # wait 'self.post_injection_time' after removing injection injection
        log.debug("Wait %s s of post-injection time\n" % self.getPostInjectionTime())
        await asyncio.sleep(self.getPostInjectionTime())

        if 'delete' in self.getFaultType():
            await self._recover_from_delete()
        else:
            return

    def make_nics_injection_command(self, node_pid, device, fault_type, fault_pattern, fault_pattern_args, fault_args,
                                    tc_cmd):
        log.debug(
            "[make_nics_injection_command] CONFIG: device %s, fault_type %s, fault_pattern %s, fault_pattern_args %s, fault_args %s, tc_cmd %s\n"
            % (device, fault_type, fault_pattern, fault_pattern_args, fault_args, tc_cmd))

        base_command = 'nsenter --target ' + str(
            node_pid) + ' --net  ' + tc_path + '/tc qdisc ' + tc_cmd + ' dev ' + device + ' root netem '
        command = None

        # NOTE: for NODE_DOWN and NIC_DOWN fault type does not make sense the random fault_pattern.
        #       we implement only a persistent flavor

        if 'random' in fault_pattern:

            if 'delay' in fault_type:
                # e.g., tc qdisc add dev tap0897f3c6-e0 root netem delay 50ms reorder 50%
                random_perc = 100 - int(fault_pattern_args)
                command = base_command + fault_type + ' ' + fault_args + ' reorder ' + str(random_perc) + '%'

            else:
                # in that case for corruption and loss we can use the 'fault_args' that already include random probability
                command = base_command + fault_type + ' ' + fault_pattern_args + '%'

        elif 'persistent' in fault_pattern:

            # Persistent fault type means setting a probability to 100%. For delay injection we can just use the default usage for 'delay' fault type

            if 'delay' in fault_type:

                command = base_command + fault_type + ' ' + fault_args

            elif 'bottleneck' in fault_type:

                # the command is like: tc qdisc add dev tapa68bfef8-df root tbf rate 256kbit burst 1600 limit 3000
                default_bottleneck_burst = '1600'
                default_limit_burst = '3000'
                command = 'nsenter --target ' + str(
                    node_pid) + ' --net  ' + tc_path + '/tc qdisc ' + tc_cmd + ' dev ' + device + ' root tbf rate ' + fault_args + 'kbit burst ' + default_bottleneck_burst + ' limit ' + default_limit_burst

            elif 'down' in fault_type:
                # TODO implement this
                if 'add' in tc_cmd:

                    # search for ifdown cmd
                    p = subprocess.Popen('whereis -b ifdown | awk \'{print $2}\'', stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
                    output, err = p.communicate()
                    ifdown_cmd = output.strip()
                    if ifdown_cmd:
                        command = ifdown_cmd + ' ' + device

                elif 'del' in tc_cmd:
                    # search for ifdown cmd
                    p = subprocess.Popen('whereis -b ifup | awk \'{print $2}\'', stdin=subprocess.PIPE,
                                         stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, text=True)
                    output, err = p.communicate()
                    ifup_cmd = output.strip()
                    if ifup_cmd:
                        command = ifup_cmd + ' ' + device


            else:
                # in that case for corruption and loss we can use the 'fault_args' to set 100% probability

                command = base_command + fault_type + ' 100%'

        return command

    def make_filter_cmds(self, node_pid, fault_pattern, fault_pattern_args, fault_type, fault_args, device,
                         target_protocol,
                         target_dst_ports=None, target_src_ports=None, enable=False):

        log.debug(
            "[make_filter_cmds] CONFIG: fault_pattern %s, fault_pattern_args %s, fault_type %s, fault_args %s, device %s, target_protocol %s, target_dst_ports %s, target_src_ports %s, enable %s\n"
            % (fault_pattern, fault_pattern_args, fault_type, fault_args, device, target_protocol, target_dst_ports,
               target_src_ports, enable))

        if enable:

            base_command = 'nsenter --target ' + str(
                node_pid) + ' --net  ' + tc_path + '/tc filter add dev ' + device + ' parent 1:0 protocol ip prio 1 u32 '
            cmd_list = [tc_path + '/tc qdisc add dev ' + device + ' root handle 1: prio']

            target_protocol_cmd = 'match ip protocol ' + self.target_protocol_table[target_protocol] + ' 0xff'

            if target_dst_ports:
                for target_port in target_dst_ports:
                    target_port_cmd = 'match ip dport ' + str(target_port) + ' 0xffff'
                    cmd_list.append(base_command + target_protocol_cmd + ' ' + target_port_cmd + ' flowid 1:1')

            if target_src_ports:
                for target_port in target_src_ports:
                    target_port_cmd = 'match ip sport ' + str(target_port) + ' 0xffff'
                    cmd_list.append(base_command + target_protocol_cmd + ' ' + target_port_cmd + ' flowid 1:1')

            else:
                cmd_list.append(base_command + target_protocol_cmd + ' flowid 1:1')

            # enable fault injection

            if 'random' in fault_pattern:

                if 'delay' in fault_type:
                    # e.g., tc qdisc add dev tap0897f3c6-e0 root netem delay 50ms reorder 50%
                    random_perc = 100 - int(fault_pattern_args)
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + fault_args + ' reorder ' + str(
                            random_perc) + '%')
                else:
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + fault_pattern_args + '%')

            elif 'persistent' in fault_pattern:

                if 'bottleneck' in fault_type:

                    # the command is like: tc qdisc add dev tapa68bfef8-df root tbf rate 256kbit burst 1600 limit 3000
                    default_bottleneck_burst = '1600'
                    default_limit_burst = '3000'
                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: tbf rate ' + fault_args + 'kbit burst ' + default_bottleneck_burst + ' limit ' + default_limit_burst)

                else:
                    if 'delay' in fault_type:
                        tc_arg = fault_args
                    else:
                        tc_arg = '100%'

                    cmd_list.append(
                        'nsenter --target ' + str(
                            node_pid) + ' --net  ' + tc_path + '/tc qdisc add dev ' + device + ' parent 1:1 handle 2: netem ' + fault_type + ' ' + tc_arg)

        else:
            cmd_list = []
            cmd_list.append(
                'nsenter --target ' + str(
                    node_pid) + ' --net  ' + tc_path + '/tc qdisc del dev ' + device + ' root handle 1: prio')

        log.debug("cmd_list generated => %s\n" % cmd_list)

        return cmd_list

    def inject_nics(self, device, node_pid, fault_type, fault_pattern, fault_pattern_args, fault_args, target_traffic,
                    target_protocol, target_dst_ports, target_src_ports, enable):

        # tc/netem commands used to inject fault
        #
        # fault_type = [ delay | loss | corrupt | duplicate | bottleneck | down | reboot]
        # fault_args = [<latency>ms | <percentage>%]
        #
        # DELAY:
        # tc qdisc add dev <nic> root netem delay <latency>ms"
        #
        # LOSS:
        # tc qdisc add dev <nic> root netem loss <percentage>%
        #
        # CORRUPT:
        # tc qdisc change dev <nic> root netem corrupt <percentage>%

        # NOTE: to handle properly floating ip injection we need to filter on floating ip
        #
        # Example:
        #
        # to enable:
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 root handle 1: prio
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc filter add dev qg-a931d750-88 parent 1:0 protocol ip prio 1 u32 match ip src 10.0.20.232 flowid 1:1
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc filter add dev qg-a931d750-88 parent 1:0 protocol ip prio 1 u32 match ip dst 10.0.20.232 flowid 1:1
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 parent 1:1 handle 2: netem delay 1000ms
        #
        # to disable:
        # ip netns exec qrouter-8f998d26-79e1-41ff-8fd8-ba362ab4fc92 tc qdisc add dev qg-a931d750-88 root handle 1: prio

        # NOTE: if self.getTargetName is not None it means that we are injecting in a floating IP address for virtual networks
        # if self.getTargetName():
        #     log.error("Going down a path removed from ThorFI: Target name. Insert it again to continue")
        #     cmd_list = []

        # NOTE: We are injecting on the other network resources except floating IP
        # if fault target is ANY_TRAFFIC call make_nics_injection_command
        if 'any' in target_traffic:

            if enable:
                # enable fault injection
                command = self.make_nics_injection_command(node_pid, device, fault_type, fault_pattern,
                                                           fault_pattern_args[0],
                                                           fault_args, 'add')
            else:
                command = self.make_nics_injection_command(node_pid, device, fault_type, fault_pattern,
                                                           fault_pattern_args[0],
                                                           fault_args, 'del')

            log.debug("Execute command in namespace for process  %s: '%s'\n" % (node_pid, command))
            retcode = call(command, shell=True)
            if retcode < 0:
                log.debug("Command '%s' was terminated not correctly (recode %s)\n" % (command, -retcode))
            else:
                log.debug("Command '%s' was terminated correctly (retcode %s)\n" % (command, retcode))

        # if fault target is not ANY_TRAFFIC generate cmds for injecting according to protocol and port number
        else:
            cmd_list = []
            if enable:
                cmd_list = self.make_filter_cmds(node_pid, fault_pattern, fault_pattern_args[0], fault_type, fault_args,
                                                 device,
                                                 target_protocol, target_dst_ports, target_src_ports, True)
            else:
                cmd_list = self.make_filter_cmds(node_pid, fault_pattern, fault_pattern_args[0], fault_type, fault_args,
                                                 device,
                                                 target_protocol, target_dst_ports, target_src_ports, False)

            for command in cmd_list:
                log.debug("Execute command in namespace for process %s: '%s'\n" % (node_pid, command))

                retcode = call(command, shell=True)  # TODO call the relevant hosts command instead
                if retcode < 0:
                    log.debug("Command '%s' was terminated not correctly (recode %s)" % (command, -retcode))
                else:
                    log.debug("Command '%s' was terminated correctly (retcode %s)" % (command, retcode))


class NodeInjector:
    def __init__(self,
                 target_process_pid=None,  # This pid represents the "node" we want to run on
                 fault_type=None,  # "stress", custom, ???
                 pre_injection_time=0,
                 injection_time=20,
                 post_injection_time=0,
                 fault_args=None,  # For stress: Percentage. For custom: Start command/end command
                 fault_pattern=None,  # persistent|burst|degradation
                 fault_pattern_args=None
                 # We want mode - for defaults like a CPU stressor, but also custom commands
                 ):
        self.target_process_pid = target_process_pid
        self.fault_type = fault_type
        self.pre_injection_time = pre_injection_time
        self.injection_time = injection_time
        self.post_injection_time = post_injection_time
        self.fault_args = fault_args
        self.fault_pattern = fault_pattern
        self.fault_pattern_args = fault_pattern_args

        if fault_type == "stress_cpu":
            self.cpu_cgroup_name = self._get_cgroup_name()

    async def go(self):
        await self.do_injection()

    def _get_cgroup_name(self):
        pid = self.target_process_pid
        path_to_process_cgroup = f"/proc/{pid}/cgroup"
        cgroup_command = ["/usr/bin/cat", f"{path_to_process_cgroup}"]  # TODO make this binary part of the distribution
        try:
            cgroup_process = subprocess.run(cgroup_command, text=True, capture_output=True)
            cgroup_process.check_returncode()
            cgroup_path = cgroup_process.stdout
            log.debug("cgroups for pid " + str(pid)+ ": " + cgroup_path)
            cpu_cgroup_pattern = r"^(\d*):cpu,cpuacct:/(.*)$"
            match = re.search(cpu_cgroup_pattern, cgroup_path, re.MULTILINE)
            cgroup_name = match.group(2)
            return cgroup_name

        except subprocess.CalledProcessError:
            log.error("Can't access cgroups information")
        return None

    def execute_command_for_node(self, pid_of_node, command_to_execute):
        base_command = f"nsenter --target {str(pid_of_node)} --net --pid --all "
        full_command = base_command + command_to_execute
        retcode = call(full_command, shell=True)
        if retcode < 0:
            log.debug("Command '%s' was terminated not correctly (recode %s)\n" % (full_command, -retcode))
        else:
            log.debug("Command '%s' was terminated correctly (retcode %s)\n" % (full_command, retcode))

    def _get_cgroup_size(self):
        size_command = ["/usr/bin/cgget", "-g", "cpu", self.cpu_cgroup_name]
        # TODO make this binary part of the distribution
        try:
            cgroup_process = subprocess.run(size_command, text=True, capture_output=True)
            cgroup_process.check_returncode()
            cpu_cgroup_details = cgroup_process.stdout

            period_regex = r"^cpu\.cfs_period_us: (\d*)$"
            quota_regex = r"^cpu\.cfs_quota_us: (\d*)$"
            cpu_period = re.search(period_regex, cpu_cgroup_details, re.MULTILINE).group(1)
            cpu_quota = re.search(quota_regex, cpu_cgroup_details, re.MULTILINE).group(1)

            cpu_ratio = int(cpu_quota) / int(cpu_period)
            return cpu_ratio
        except subprocess.CalledProcessError:
            log.error("Tried to find cgroup size for " + self.cpu_cgroup_name + ", but couldn't find it\n")
            return None

    async def _inject_burst(self):
        if self.fault_type == 'custom':
            burst_config = self.fault_pattern_args
            burst_duration = int(burst_config[0]) / 1000
            burst_period = int(burst_config[1]) / 1000  # after each burst, wait for (burst_period - burst_duration)
            burst_num = int((self.injection_time) / burst_period)  # how often we burst

            start_command = self.fault_args[0]
            end_command = self.fault_args[1]

            for _ in range(burst_num):
                self.execute_command_for_node(self.target_process_pid, start_command)
                await asyncio.sleep(burst_duration)
                self.execute_command_for_node(self.target_process_pid, end_command)
                await asyncio.sleep(burst_period - burst_duration)

        elif self.fault_type == 'stress_cpu':
            burst_config = self.fault_pattern_args # TODO shift this to use the /1000 format - for consistency
            burst_duration = int(max(1, burst_config[0]/1000))
            burst_period = int(burst_config[1]) / 1000  # after each burst, wait for (burst_period - burst_duration)
            burst_num = int(self.injection_time / burst_period)  # how often we burst

            cgroup_fraction = self._get_cgroup_size()
            cpu_stress_percentage = int(self.fault_args[0])
            stress_percentage_applied_to_cgroup = int(cpu_stress_percentage * cgroup_fraction)

            stress_command = f"stress-ng -l {stress_percentage_applied_to_cgroup} -t {burst_duration} --cpu 1 --cpu-method decimal64"

            for _ in range(burst_num):
                self.execute_command_for_node(self.target_process_pid, stress_command)
                await asyncio.sleep(burst_period - burst_duration)
        # TODO handle else case


    async def _inject_degradation(self):
        if self.fault_type == 'custom':
            start_base_command = self.fault_args[0]
            end_base_command = self.fault_args[1]

            if len(self.fault_args) > 2:
                step_start = int(self.fault_args[2])
            else:
                step_start = 0

            step_size = int(self.fault_pattern_args[0])
            step_duration = int(self.fault_pattern_args[1])

            # TODO verify that {} and number of arguments is the same
            # TODO also skip argument insertaion if
            # TODO expand this to allow for multiple arguments - but later
            test_duration = 0

            injection_intensity = step_start
            while test_duration < self.injection_time:

                start_command = start_base_command.format(injection_intensity)
                end_command = end_base_command

                self.execute_command_for_node(self.target_process_pid, start_command)
                await asyncio.sleep(step_duration)
                self.execute_command_for_node(self.target_process_pid, end_command)

                injection_intensity = injection_intensity + step_size
                test_duration += step_duration
        elif self.fault_type == 'stress_cpu':
            # increment by fault_pattern_args[0] every fault_pattern_args[1]
            cgroup_fraction = self._get_cgroup_size()
            cpu_stress_starting_percentage = int(self.fault_args[0])
            step_size_in_percent = int(self.fault_pattern_args[0])
            stress_step_duration = int(self.fault_pattern_args[1])

            starting_stress_applied_to_cgroup = int(cpu_stress_starting_percentage * cgroup_fraction)
            stress_base_command = "stress-ng -l {} -t {} --cpu 1 --cpu-method decimal64"

            test_duration = 0
            # TODO probably limit to 100%? The other stressers as well
            injection_intensity = starting_stress_applied_to_cgroup
            while test_duration < self.injection_time:
                stress_command = stress_base_command.format(injection_intensity, stress_step_duration)
                self.execute_command_for_node(self.target_process_pid, stress_command)
                injection_intensity = int(injection_intensity + (step_size_in_percent * cgroup_fraction))
                test_duration += stress_step_duration
                # No need to sleep, command runs for as long as indicated
        # TODO handle else case

    async def _inject_static(self):
        # Build up
        if self.fault_type == 'custom':
            duration_in_seconds = self.injection_time

            start_command = self.fault_args[0]
            end_command = self.fault_args[1]
            self.execute_command_for_node(self.target_process_pid, start_command)
            await asyncio.sleep(duration_in_seconds)
            self.execute_command_for_node(self.target_process_pid, end_command)

        elif self.fault_type == 'stress_cpu':
            # inject here
            # Users want n % cpu usage _on a node_ (=cgroup), but the stress-ng takes a global load.
            # To get our in-cpu we reduce the stress instruction by however much cpu is not allowed in our cgroup
            cgroup_fraction = float(self._get_cgroup_size())
            cpu_stress_percentage = float(self.fault_args[0])
            stress_percentage_applied_to_cgroup = int(cpu_stress_percentage * cgroup_fraction)
            duration_in_seconds = self.injection_time
            stress_base_command = f"stress-ng -l {stress_percentage_applied_to_cgroup} -t {duration_in_seconds} --cpu 1 --cpu-method decimal64"
            self.execute_command_for_node(self.target_process_pid, stress_base_command)
            # No need to sleep, command runs for as long as indicated
        # TODO handle else case

    async def do_injection(self):
        # TODO sensible logging downstream from here
        await asyncio.sleep(self.pre_injection_time)
        if self.fault_pattern == 'burst':
            await self._inject_burst()
        elif self.fault_pattern == 'degradation':
            await self._inject_degradation()
        elif self.fault_pattern == 'static':
            await self._inject_static()
        # TODO handle else case

        await asyncio.sleep(self.post_injection_time)
        return
